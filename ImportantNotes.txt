
*Javascript Notes*
  Chapter 1:

Define Javascript: JAVASCRIPT IS A HIGH-LEVEL,OBJECT-ORIENTED, MULTI-PARADIGM PROGRAMMING LANGUAGE.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Datatypes:
 There were seven datatypes is Javascript:
 1. Number: Floating point numbers. Used for decimals and integers. Ex: let age= 23;
 2. String: Sequence of characters . Used for text . Ex: let name= 'abcd';
 3. Boolean: Logical type that can only be true or false. Used for taking decisions. Ex: let canDrive= true;
 4. Undefined: Value taken by a variable that is not yet defined (‘empty value’)
 5. Null: Also means ‘empty value’
 6. Symbol (ES2015): Value that is unique and cannot be changed [Not useful for now]
 7. BigInt (ES2020): Larger integers than the Number type can hold

NOTE: JavaScript has dynamic typing: We do not have to manually define the data type of the value stored in a variable. Instead, data types are determined             automatically.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
BOOLEAN LOGIC:
 1. AND(&&): True when all conditions are true.
 2. OR(||): True when any one of the given conditions is true.
 3. NOT(!): Inverts true/false value.

NOTE: For linking javascript file to you html just under the script tag put the name of your javascript file with ".js" . EX: <script src= "script.js"></script>
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
VALUE & VARIABLE:

Value: It is a piece of data.
       Ex: 'name' , 15
Variable: It is like a space in memory that programmer create to hold diffrent values so that they can use it further in program.
          Ex: number = 15

NOTE: Every value in javascript is of two types 1. Primitive i.e.: let name = 'abcd' or let number = 15
                                                2. Object i.e.: let name { name= 'abcd' };
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
let, const, var

let: 1. Can be re-assigned after declaration.
        Ex: If we declare a variable "let age = 30;" we can re-assign in further program as "age = 31;"
     2. The scope of a let variable is only block scoped. It can’t be accessible outside the particular block ({block})
     3. If users use the let variable before the declaration, it does not initialize with undefined it will throw error.

const: 1. const keyword has all the properties that are the same as the let keyword, except the user cannot update it.
       2. The scope of a const variable is only block scoped. The user cannot update the const variable once it is declared.

var: 1. The scope of a var variable is functional scope or global scoped.
     2. The user can re-declare the variable using var and the user can update var variable.
     3. If users use the var variable before the declaration, it initializes with the undefined value.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
OPERATOR: Operators are used to transform or combine multiple values.
Types of operators
 1. Arithmetic Operators: Used to perform arithmetic operations on numbers. i.e.: let sum= 2+3;
                          Addtion(+), Subtraction(-), Multiplication(*), Exponentiation(**), Division(/), Modulus(%), Increment(++), Decrement(--).

 2. Assignment operators: Used to assign values to JavaScript variables. (= , += , -=, *=, /=, %=, **=)

 3. Comparison Operators: Used to compare two values and always return boolean value(TRUE/FALSE).
                          Equal to(==), equal value and equal type(===), not equal(!=), not equal value or not equal type(!==), greater than(>), less than(<),
                          greater than equal to(>=), less than equal to(<=), ternary operator(?)

 4. Logical Operators: Comparison operators are used in logical statements to determine equality or difference between variables or values.
                       logical AND(&&), logical OR(||), logical NOT(!).

 5. Type Operators: typeof - Returns the type of variable.
                    instanceof - Returns true if an object is an instance of an object type

 6. Bitwise Operators: Bit operators work on 32 bits numbers.Any numeric operand in the operation is converted into a 32 bit number. The result is converted back to a                         JavaScript number. EX. "5 & 1" is same as "0101 & 0001"
                       AND(&), OR(|), NOT(~), XOR(^),left shift(<<), right shift(>>), unsigned right shift(>>>).

NOTE: '+' is the only overloaded operator in javasript. It can be used to add and concatenate strings. If you add a number and a string, the result will be a string!
 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Template Literals:

1. Use back-ticks (``) rather than the quotes ("") to define a string. Ex: let text = `Hello World!`;
2. With template literals, you can use both single and double quotes inside a string. Ex: let text = `He's often called "Johnny"`;
3. Template literals provide an easy way to interpolate variables and expressions into strings.The method is called string interpolation. Syntax: ${...}
4. Template literals allow variables in strings. Ex: let text = `Welcome ${firstName}, ${lastName}!`;
5. Automatic replacing of variables or experession with real values is called string interpolation.
6. Template literals allow expressions in strings. Ex: let total = `Total: ${(price * (1 + VAT)).toFixed(2)}`;
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
if/else Statement: Used to perform different actions based on different conditions.

1. if Statement: The if statement to specify a block of JavaScript code to be executed if a condition is true.
                 if (condition) {
                      //  block of code to be executed if the condition is true
                 }
2.else Statement: The else statement to specify a block of code to be executed if the condition is false.
                  if (condition) {
                      //  block of code to be executed if the condition is true
                  } else {
                     //  block of code to be executed if the condition is false
                  }
3.else if Statement: Use the else if statement to specify a new condition if the first condition is false.
                    if (condition1) {
                      //  block of code to be executed if condition1 is true
                     } else if (condition2) {
                      //  block of code to be executed if the condition1 is false and condition2 is true
                     } else {
                       //  block of code to be executed if the condition1 is false and condition2 is false
                     }
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
TYPE CONVERSION vs COERCION:

Conversion: When we manually convert the type of variable.
            Ex: const inputYear = '1991';
                console.log(inputYear+18); 199118
                console.log(Number(inputYear) + 18); 1991+18= 2009
NOTE: If you try to convert a srting to number type then we get 'NaN' as ouput.
            Ex: console.log(Number('abcd'); NaN

Coercion: When javascript convert the type of variable automatically.
          Ex. console.log('I am ' + 23 + ' years old'); // I am 23 years old
NOTE:Except '+' other Arithmetic operator converts srting to number when performed together.
         Ex: console.log('23' - '10' - 3); //10
             console.log('23' * '2'); //46
             console.log('1'+ '1'); //11
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Truthy and Falsy value:
 1. Falsy value: Value which are not exactly false but will come false when we try to convert them to boolean.
    5 falsy values: 0, '', undefined, null, NaN
    Ex.: console.log(Boolean(0)); // false
         console.log(Boolean('abcd')); //true 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
== vs ===
1.Double equals (==) will perform a type conversion when comparing two things.It is also called as loose equality.
  Ex: console.log('18' == 18); true
2.Triple equals (===) will do the same comparison as double equals but without type conversion; if the types differ, false is returned.
  Ex. console.log('18' == 18); //false
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Switch Statement: The switch statement is used to perform different actions based on different conditions.
Syntax: switch(expression) {
          case x:
           // code block
           break;
          case y:
           // code block
          break;
         default:                 // The default keyword specifies the code to run if there is no case match:

         // code block
    }

Note: If you omit the break statement, the next case will be executed even if the evaluation does not match the case.
      Switch cases use strict comparison (===).
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Statement vs Experssion:

1. Experssion: It is a piece of code which produces a value. Ex.3 + 4 , 1991 ,  true && false && !false
              
2. Statement: It a piece of code which produces a value or a sequance of action is also called as statement.
   Ex.: if (23 > 10) {
        const str = '23 is bigger';
       }
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Conditional (Ternery) operator: A ternary operator can be used to replace an if..else statement in certain situations.
                                A ternary operator evaluates a condition and executes a block of code based on the condition.

                                Syntax: condition ? expression1 : expression2

                                 If the condition is true, expression1 is executed.
                                 If the condition is false, expression2 is executed. 

Ex: const age = 23;
    // age >= 18 ? console.log('I like to drink wine') : console.log('I like to drink water');     
----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
'strict mode' :
1. "use strict"; Defines that JavaScript code should be executed in "strict mode".
2. Strict mode is declared by adding "use strict"; to the beginning of a script or a function.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
Function in JavaScript:It is a block of code designed to perform a particular task.

Syntax: function name(parameter1, parameter2, parameter3) {
         // code to be executed
        }    
Ex: let x = myFunction(4, 3);   // Function is called, return value will end up in x

function myFunction(a, b) {
         return a * b;             // Function returns the product of a and b
       }

Function Declaration: A function declaration also known as a function statement declares a function with a function keyword. The function declaration must have a                       function name.
                      Syntax: function func(paramA, paramB) {
                                // Set of statements
                               } 

Function Expression: A function Expression is similar to a function declaration without the function name. Function expressions can be stored in a variable assignment.
                     Syntax: let func= function(paramA, paramB) {
                              // Set of statements
                             }

Arrow Function: Syntax: let hello = () => {
                        return "Hello World!";
                         }

Function calling other function: In JavaScript we call one function inside the other function.

Ex: 
function cutFruitPieces(fruit) {
  return fruit * 4;
}

function fruitProcessor(apples, oranges) {
  const applePieces = cutFruitPieces(apples);
  const orangePieces = cutFruitPieces(oranges);

  const juice = `Juice with ${applePieces} piece of apple and ${orangePieces} pieces of orange.`;
  return juice;
}
console.log(fruitProcessor(2, 3));
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Arrays: An array is a special variable, which can hold more than one value.
        Syntax: const array_name = [item1, item2, ...];
                const array_name = new Array(item1, item2, ....); 
        Ex: const cars = ["Saab", "Volvo", "BMW"];

Accessing array element: An array element can be accessed by referring to the index number. i.e.: console.log(array_name[index]);

Array element can be changed later in program.
Ex: const cars = ["Saab", "Volvo", "BMW"];
    cars[0] = "Alto"; // changes the 0th index of array cars.

Array operation:

push(): Adds new elements to the end of an array, and returns the new length. Syntax: array_name.push(value);

Note: There are more array operation method in javascript that can be explored through internet.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Objects: Objects are variables too. But objects can contain many values. Object values are written as name : value pairs (name and value separated by a colon). 
         Ex: let person = {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};
         The named value in objects is called as Property.

Retrive data from object: Data from object can be retrived by using two method i.e.-
 1. Dot notation(.): let person = {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};
                     console.log(person.lastName); // "Doe"
 2. Bracket Notation([]): let person = {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};
                     console.log(person[lastName]); // "Doe"
NOTE: In bracket notation we can use any expression in place of string while retriving the data from object.
      Ex: let person = {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};
          const nameKey= Name;
          console.log(person['fisrt' + nameKey]);
          console.log(person['last' + nameKey]);

Updating the object:
1. Using Dot notation: person.location= 'India'
2. Using Bracket notation: person[location]= 'India'

Methods in Object: Methods are functions stored as object properties.
                   Syntax to access method from object: objectName.methodName();

What is "this" in javascript:
 1)the this keyword refers to an object.
 2)In strict mode, this is undefined.
 3)In an event, this refers to the element that received the event.
 4)Methods like call(), apply(), and bind() can refer this to any object.

Ex: const jonas = {
  firstName: 'Jonas',
  lastName: 'Schmedtmann',
  birthYeah: 1991,
  job: 'teacher',
  friends: ['Michael', 'Peter', 'Steven'],
  hasDriversLicense: true,
}
calcAge: function () {
    this.age = 2037 - this.birthYeah;
    return this.age;
  },
console.log(jonas.age);
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
LOOP: Loops are handy, if you want to run the same code over and over again, each time with a different value. Loops are very handy when working with arrays.


FOR LOOP : The for statement creates a loop with 3 optional expressions:
           1. Expression 1 is executed (one time) before the execution of the code block.

           2. Expression 2 defines the condition for executing the code block.

           3. Expression 3 is executed (every time) after the code block has been executed.
Syntax: for (expression 1; expression 2; expression 3) {
            // code block to be executed
        }

Break statement: The break statement "jumps out" of a loop.
                 Ex: for (let i = 0; i < 10; i++) {
                        if (i === 3) { break; }
                      text += "The number is " + i + "<br>";
                     }
In the example above, the break statement ends the loop ("breaks" the loop) when the loop counter (i) is 3

Continue statement: The continue statement "jumps over" one iteration in the loop.
                    Ex: for (let i = 0; i < 10; i++) {
                        if (i === 3) { continue; }
                        text += "The number is " + i + "<br>";
                        }
In the example above, the continue statement skips the value of 3 when the loop counter(i) is 3.

Loop Backward: We can access the array element in in backward direction by runnung the loop in backward direction.
               Ex: const number = [1, 2, 3, 4, 5, 6, 7,];
                   for(i= number.length; i>=0; i--){
                      console.log(number[i])
                   }

Nested for loop: A nested for loop on the other hand, resides one or more for loop inside an outer for loop.
                 Syntx: for(let i = 0 ; i < limit; i++){
                        for(let j = 0 ; j < limit; j++){
                          // statement
                   }
                       // statement for outer loop
                 }

While Loop: The while loop loops through a block of code as long as a specified condition is true. This loop is used when developer don't know how many times the             counter need to run.
            Syntx: while (condition) {
                   // code block to be executed
                 }
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------DOM: It stands for "Document object model". It is a structured represantation of HTML document that allows Javascript to access HTML element and style to manipulate         them.The HTML DOM model is constructed as a tree of Objects.

DOM Method:
1. querySelector(): The querySelector() method returns the first element that matches a CSS selector. To return all matches (not only the first), use the                     querySelectorAll() instead.
                    Both querySelector() and querySelectorAll() throw a SYNTAX_ERR exception if the selector(s) is invalid.
   Syntax:         document.querySelector(CSS selectors)
   Ex    :         Get the first <p> element in with class="example": document.querySelector("p.example");
                   Change the text of the element with id="demo": document.querySelector("#demo").innerHTML = "Hello World!";

2. addEventListener(): The addEventListener() method attaches an event handler to a document.
               Syntax: document.addEventListener(event, function, Capture)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
One more defination of JavaScript: JAVASCRIPT IS A HIGH-LEVEL, PROTOTYPE-BASED OBJECT-ORIENTED, MULTI-PARADIGM, INTERPRETED OR JUST-IN-TIME COMPILED, DYNAMIC, SINGLE-                                     THREADED, GARBAGE-COLLECTED PROGRAMMING LANGUAGE WITH FIRST-CLASS FUNCTIONS AND A NON-BLOCKING EVENT LOOP CONCURRENCY MODEL.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Destructing Arrays: It is the process by which we can extract only that items from array that is needed not whole array.
                    When destructuring arrays, the order that variables are declared is important.

Example: Without destructuring:                           
const vehicles = ['mustang', 'f-150', 'expedition'];
// old way
const car = vehicles[0];
const truck = vehicles[1];
const suv = vehicles[2];

With destructuring: 

const vehicles = ['mustang', 'f-150', 'expedition'];
const [car, truck, suv] = vehicles;

If we only want the car and suv we can simply leave out the truck but keep the comma:
const [car,, suv] = vehicles;

Array destructuring and Default values: If you are taking a value from the array and that value is undefined, then you can assign a default value to a variable.

Swapping Variables: The values of the two variables can be swapped in one destructuring expression. The array destructuring makes it easy to swap the values of                     variables without using any temporary variable.
Ex: var x = 100, y = 200;  
    [x, y] = [y, x];  
    console.log(x); // 200  
    console.log(y); // 100 

Parsing returned array from functions : A function can return an array of values. It is always possible to return an array from a function, but array destructuring                                        makes it more concise to parse the returned array from functions.
Ex: function array() {  
    return [100, 200, 300];  
}  
var [x, y, z] = array();
console.log(x); //100
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Destructuring Objects: It is similar to array destructuring except that instead of values being pulled out of an array, the properties (or keys) and their                        corresponding values can be pulled out from an object.
                       When destructuring the objects, we use keys as the name of the variable. The variable name must match the property (or keys) name of the object.                        If it does not match, then it receives an undefined value. This is how JavaScript knows which property of the object we want to assign.
Ex: const num = {x: 100, y: 200};  
    const {x, y} = num;  
    console.log(x); // 100

Like array destructuring, a default value can be assigned to the variable if the value unpacked from the object is undefined.
Example: const {x = 100, y = 200} = {x: 500};  
         console.log(x); // 500   value: reassigned
         console.log(y); // 200 

Assigning new variable names: We can assign a variable with a different name than the property of the object.
Example: const num = {x: 100, y: 200};  
         const {x: new1, y: new2} = num;  
   
         console.log(new1); //100   
         console.log(new2); //200   

Assignment without declaration: If the value of the variable is not assigned when you declare it, then you can assign its value during destructuring.
Example: let name, division;  
         ({name, division} = {name: 'Anil', division: 'First'});   
          console.log(name); // Anil  
          console.log(division); // First  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Spread Operator: The JavaScript spread operator (...) allows us to quickly copy all or part of an existing array or object into another array or object.
           Ex:   const numbersOne = [1, 2, 3];
                 const numbersTwo = [4, 5, 6];
                 const numbersCombined = [...numbersOne, ...numbersTwo];

The spread operator is often used in combination with destructuring.
Ex: Assign the first and second items from numbers to variables and put the rest in an array:
    const numbers = [1, 2, 3, 4, 5, 6];
    const [one, two, ...rest] = numbers;

Spread operator can use the spread operator with objects too.
Ex: const myVehicle = {
  brand: 'Ford',
  model: 'Mustang',
  color: 'red'
}
const updateMyVehicle = {
  type: 'car',
  year: 2021, 
  color: 'yellow'
}
const myUpdatedVehicle = {...myVehicle, ...updateMyVehicle}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Rest pattern and parameter: The rest parameter is an improved way to handle function parameters, allowing us to more easily handle various inputs as parameters in a                             function. The rest parameter syntax allows us to represent an indefinite number of arguments as an array. With the help of a rest                             parameter, a function can be called with any number of arguments, no matter how it was defined.
Note: When … is at the end of the function parameter, it is the rest parameter. It stores n number of parameters as an array.

Ex: Without rest parameter: 
    function fun(a, b){
        return a + b;
    }
    console.log(fun(1, 2)); // 3
    console.log(fun(1, 2, 3, 4, 5)); // 3 

With Rest parameter: 
function fun(...input){
        let sum = 0;
        for(let i of input){
            sum+=i;
        }
        return sum;
    }
    console.log(fun(1,2)); //3
    console.log(fun(1,2,3)); //6
    console.log(fun(1,2,3,4,5)); //15 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Nullish Coalescing Operator(??): This operator returns the right hand value if the left hand value is null or undefined. If not null or undefined then it will return                                    left hand value.
Syntax: variable ?? default_value
Example: function foo(bar) {
         bar = bar ?? 42;
         console.log(bar);
        }
         foo();  // 42
         foo(0); // 0
In above example, If the passed variable is either null or undefined and only if it’s those two values, the default value would be returned. In all other cases including 0, empty string, or false, the value of the variable is returned and not the default value.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
The For Of Loop: The JavaScript for of statement loops through the values of an iterable object.
Example: 
const cars = ["BMW", "Volvo", "Mini"];
let text = "";
for (let x of cars) {
  text += x;
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Optional Chaining (?.): The optional chaining operator (?.) allows you to access the value of a property located deep within a chain of objects without explicitly                         checking if each reference in the chain is null or undefined. If one of the references in the chain is null or undefined, the optional chaining                         operator (?.) will short circuit and return undefined.
                        The Optional Chaining Operator allows a developer to handle many of those cases without repeating themselves and/or assigning intermediate                         results in temporary variables:
Ex:                     With optional chaining we can write this (let Value = user.dog?.name;) instead of (let Value = user.dog && user.dog.name;)

Example: Optional Chaining with Object:
 
const user = {
  dog: {
    name: "Alex"
  }
};
 
console.log(user.cat?.name); //undefined
console.log(user.dog?.name); //Alex
console.log(user.cat.name);

Example Optional Chaining with Function Call:

let user1 = () => console.log("Alex");
let user2 = {
  dog(){
    console.log("I am Alex");
  }
}
let user3 = {};
 
user1?.();       // Alex
user2.dog?.();   // I am Alex
user3.dog();     // ERROR - Uncaught TypeError:
                 // user3.dog is not a function.
user3.dog?.();   // Will not generate any error.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
SETS: A JavaScript Set is a collection of unique values.Each value can only occur once in a Set.A Set can hold any value of any data type.

Some useful SET methos: 
1)new Set(): Creates a new Set
2)add(): Adds a new element to the Set
3)delete() :Removes an element from a Set
4)has()	: Returns true if a value exists
5)clear():Removes all elements from a Set
6)forEach():Invokes a callback for each element
7)values():Returns an Iterator with all the values in a Set
8)keys(): Same as values()
9)entries():Returns an Iterator with the [value,value] pairs from a Set

Creation of new SET: const letters = new Set(["a","b","c"]); or 
                     const letter = new Set(); 
                     letters.add("a");

A Set has no keys. entries() returns [value,value] pairs instead of [key,value] pairs.This makes Sets compatible with Maps.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
MAPS: A Map holds key-value pairs where the keys can be any datatype. A Map remembers the original insertion order of the keys. A Map has a property that represents       the size of the map.
Some useful methon MAP methods: 
new Map()	Creates a new Map object
set()	Sets the value for a key in a Map
get()	Gets the value for a key in a Map
clear()	Removes all the elements from a Map
delete()	Removes a Map element specified by a key
has()	Returns true if a key exists in a Map
forEach()	Invokes a callback for each key/value pair in a Map
entries()	Returns an iterator object with the [key, value] pairs in a Map
keys()	Returns an iterator object with the keys in a Map
values()	Returns an iterator object of the values in a Map

You can create a JavaScript Map by:Passing an Array to new Map() and Create a Map and use Map.set().
Example: const fruits = new Map([
         ["apples", 500],
         ["bananas", 300],
         ["oranges", 200]
          ])

Iterate through the MAP:The Map.forEach method is used to loop over the map with the given function and executes the given function over each key-value pair.
Syntax: myMap.forEach(callback, value, key, thisArg)
Example: 
    // Creating a map using Map object
    let mp=new Map()
     
    // Adding values to the map
    mp.set("a",1);
    mp.set("b",2);
    mp.set("c",3);
     
    // Logging map object to console
    mp.forEach((values,keys)=>{
      console.log(values,keys)
    })
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Fuctions: A JavaScript function is a block of code designed to perform a particular task. A JavaScript function is executed when "something" invokes it (calls it).
Example: 
// Function to compute the product of p1 and p2
function myFunction(p1, p2) {
  return p1 * p2;
}

Function Invocation: 
1)When an event occurs (when a user clicks a button)
2)When it is invoked (called) from JavaScript code
3)Automatically (self invoked)

Defualt Parameter: If a function in JavaScript is called with missing arguments (less than declared), the missing values are set to undefined.
Example 1: 
function myFunction(x, y) {
  if (y === undefined) {
    y = 2;
  }
}

Example 2: 
function myFunction (x, y = 2) {
  // function code
}

Pass by value: Pass By Value: In Pass by value, function is called by directly passing the value of the variable as an argument. So any changes made inside the function does not affect the original value.

In Pass by value, parameters passed as an arguments create its own copy. So any changes made inside the function is made to the copied value not to the original value.
Ex: 
function Passbyvalue(a, b) {
	let tmp;
	tmp = b;
	b = a;
	a = tmp;
	console.log(`Inside Pass by value
		function -> a = ${a} b = ${b}`);
}

let a = 1;
let b = 2;
console.log(`Before calling Pass by value
		Function -> a = ${a} b = ${b}`);

Passbyvalue(a, b);

console.log(`After calling Pass by value
	Function -> a =${a} b = ${b}`);

Output: 
Before calling Pass by value Function -> a = 1 b = 2
Inside Pass by value function -> a = 2 b = 1
After calling Pass by value Function -> a =1 b = 2

Pass by Referance: In Pass by Reference, Function is called by directly passing the reference/address of the variable as an argument. So changing the value inside the function also change the original value. In JavaScript array and Object follows pass by reference property.
In Pass by reference, parameters passed as an arguments does not create its own copy, it refers to the original value so changes made inside function affect the original value.

Ex:
function PassbyReference(obj) {
	let tmp = obj.a;
	obj.a = obj.b;
	obj.b = tmp;

	console.log(`Inside Pass By Reference
		Function -> a = ${obj.a} b = ${obj.b}`);
}

let obj = {
	a: 10,
	b: 20

}
console.log(`Before calling Pass By Reference
	Function -> a = ${obj.a} b = ${obj.b}`);

PassbyReference(obj)

console.log(`After calling Pass By Reference
	Function -> a = ${obj.a} b = ${obj.b}`);

Output: 
Before calling Pass By Reference Function -> a = 10 b = 20
Inside Pass By Reference Function -> a = 20 b = 10
After calling Pass By Reference Function -> a = 20 b = 10

Note: In Pass by Reference, we are mutating the original value. when we pass an object as an arguments and update that object’s reference in the function’s context, that won’t affect the object value. But if we mutate the object internally, It will affect the object 

First class Function: A programming language is said to have First-class functions if functions in that language are treated like other variables. So the functions can be assigned to any other variable or passed as an argument or can be returned by another function.
JavaScript treat function as a first-class-citizens. This means that functions are simply a value and are just another type of object.

Example:
const Arithmetics = {
	add:(a, b) => {
		return `${a} + ${b} = ${a+b}`;
	},
	subtract:(a, b) => {
		return `${a} - ${b} = ${a-b}`
	},
	multiply:(a, b) => {
		return `${a} * ${b} = ${a*b}`
	},
	division:(a, b) => {
		if(b!=0) return `${a} / ${b} = ${a/b}`;
		return `Cannot Divide by Zero!!!`;
	}

}

console.log(Arithmetics.add(100, 100));
console.log(Arithmetics.subtract(100, 7));
console.log(Arithmetics.multiply(5, 5));
console.log(Arithmetics.division(100, 5));

In the above program, functions are stored as a variable in an object.
"100 + 100 = 200"
"100 - 7 = 93"
"5 * 5 = 25"
"100 / 5 = 20"

Higher Order Function: A function that receives another function as an argument or that returns a new function or both is called Higher-order function. Higher-order functions are only possible because of the First-class function.
Example:
const greet = function(name){
	return function(m){
	
		console.log(`Hi!! ${name}, ${m}`);
	}
}

const greet_message = greet('ABC');
greet_message("Welcome")

Note: The function that we pass as an argument to another function is called the callback function.Functions such as filter(), map(), reduce(), some(), etc, all are       examples of Higher-Order Functions.

Function accepting callback function: A callback is a function passed as an argument to another function.This technique allows a function to call another function. A                                       callback function can run after another function has finished.
Example:
function myDisplayer(some) {
  document.getElementById("demo").innerHTML = some;
}

function myCalculator(num1, num2, myCallback) {
  let sum = num1 + num2;
  myCallback(sum);
}

myCalculator(5, 5, myDisplayer);

Using a callback, you could call the calculator function (myCalculator) with a callback (myCallback), and let the calculator function run the callback after the calculation is finished.

In the example above, myDisplayer is a called a callback function.Note
When you pass a function as an argument, remember not to use parenthesis.
myCalculator(5, 5, myDisplayer);It is passed to myCalculator() as an argument.

call() Method: The call() method is a predefined JavaScript method. It can be used to invoke (call) a method with an owner object as an argument (parameter).
               With call(), an object can use a method belonging to another object.
Example: 
const person = {
  fullName: function() {
    return this.firstName + " " + this.lastName;
  }
}
const person1 = {
  firstName:"John",
  lastName: "Doe"
}
const person2 = {
  firstName:"Mary",
  lastName: "Doe"
}

// This will return "John Doe":
person.fullName.call(person1);

call() method with argument: 
Example:
const person = {
  fullName: function(city, country) {
    return this.firstName + " " + this.lastName + "," + city + "," + country;
  }
}
const person1 = {
  firstName:"John",
  lastName: "Doe"
}
person.fullName.call(person1, "Oslo", "Norway");

bind() method: With the bind() method, an object can borrow a method from another object.

Example:
const person = {
  firstName:"John",
  lastName: "Doe",
  fullName: function () {
    return this.firstName + " " + this.lastName;
  }
}

const member = {
  firstName:"Hege",
  lastName: "Nilsen",
}

let fullName = person.fullName.bind(member);

In above example creates 2 objects (person and member).The member object borrows the fullname method from the person object.

Note: By the use of bind() method we can preserve "this" keyword.
Example:
const person = {
  firstName:"John",
  lastName: "Doe",
  display: function () {
    let x = document.getElementById("demo");
    x.innerHTML = this.firstName + " " + this.lastName;
  }
}

setTimeout(person.display, 3000);

In above example will try to display the person name after 3 seconds, but it will display undefined instead.

const person = {
  firstName:"John",
  lastName: "Doe",
  display: function () {
    let x = document.getElementById("demo");
    x.innerHTML = this.firstName + " " + this.lastName;
  }
}

let display = person.display.bind(person);
setTimeout(display, 3000);

In above example the bind() method is used to bind person.display to person will display the person name after 3 seconds:

CLOSER:A closure is a feature of JavaScript that allows inner functions to access their outer scope. Closure helps in binding a function to its outer boundary and is        created automatically whenever a function is created. A block is also treated as a scope since ES6. Since JavaScript is event-driven so closures are useful as        it helps to maintain the state between events.
       In other words, closure is created when a child function keep the environment of the parent scope even after the parent function has already executed.
Example: 
function numberGenerator() {
  // Local “free” variable that ends up within the closure
  var num = 1;
  function checkNumber() { 
    console.log(num);
  }
  num++;
  return checkNumber;
}

var number = numberGenerator();
number(); // 2    

Explanation: 
In the example above, the function numberGenerator creates a local “free” variable num (a number) and checkNumber (a function which prints num to the console).
The function checkNumber doesn’t have any local variables of its own — however, it does have access to the variables within the outer function, numberGenerator, because of a closure.
Therefore, it can use the variable num declared in numberGenerator to successfully log it to the console even after numberGenerator has returned.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

     


